import { TemporalXAxisComponent } from "./TemporalXAxisComponent-f960f34b";
import { ChartComponentData } from "./ChartComponentData-72034d1d";
declare class LineChartData extends ChartComponentData {
    timeMap: any;
    get yExtents(): Array<any>;
    private _yExtents;
    setYExtents(idx: number, value: [
        number,
        number
    ]): void;
    resetYExtents(): void;
    setTimeMap(): void;
    constructor();
    mergeDataToDisplayStateAndTimeArrays(data: any, aggregateExpressionOptions?: any): void;
}
declare class LineChart extends TemporalXAxisComponent {
    private targetElement;
    private focus;
    private horizontalValueBox;
    private verticalValueBox;
    private horizontalValueBar;
    private contextMenu;
    private brushContextMenu;
    private setDisplayStateFromData;
    private minBrushWidth;
    private strokeOpacity;
    private nonFocusStrokeOpactiy;
    chartComponentData: LineChartData;
    private surpressBrushTimeSet;
    private hasStackedButton;
    private stackedButton;
    private visibleAggCount;
    private swimLaneLabelGroup;
    private horizontalLabelOffset;
    private tooltip;
    private height;
    private xLowerBound;
    private xUpperBound;
    private y;
    private yMap;
    private line;
    private areaPath;
    private envelope;
    private voronoi;
    private possibleTimesArray;
    private colorMap;
    private markers;
    private seriesLabelsMarker;
    private markerGuidMap;
    private isDroppingMarker;
    private activeMarker;
    private brush;
    private brushElem;
    brushStartTime: Date;
    brushEndTime: Date;
    private brushStartPosition;
    private brushEndPosition;
    private hasBrush;
    private isClearingBrush;
    private previousAggregateData;
    private previousIncludeDots;
    private voronoiDiagram;
    private voronoiRegion;
    private mx;
    private my;
    private focusedAggKey;
    private focusedSplitby;
    private plotComponents;
    private isFirstMarkerDrop;
    private xOffset;
    private swimlaneYExtents;
    private swimLaneContents;
    private originalSwimLanes;
    private originalSwimLaneOptions;
    constructor(renderTarget: Element);
    LineChart(): void;
    //get the left and right positions of the brush
    getBrushPositions(): {
        leftPos: any;
        rightPos: any;
    };
    private resetValueElementsFocus;
    private hideFocusElements;
    private voronoiMouseout;
    private createMarkerInstructions;
    private destroyMarkerInstructions;
    triggerLineFocus: (aggKey: string, splitBy: string) => void;
    private getMouseoverFunction;
    private getMouseoutFunction;
    private focusOnlyHoveredSeries;
    private discreteEventsMouseover;
    private discreteEventsMouseout;
    private mismatchingChartType;
    private categoricalMouseover;
    private categoricalMouseout;
    private setHorizontalValuePosAndText;
    private setVerticalValueAndPosition;
    private voronoiMouseover;
    //get the extent of an array of timeValues
    private getYExtent;
    private getFilteredValues;
    private getFilteredAndSticky;
    stickyOrUnstickySeries: (aggKey: any, splitBy: any) => void;
    unstickySeries: (aggKey: any, splitby?: any) => void;
    private stickySeries;
    private getHandleHeight;
    private getXPosition;
    setBrushStartTime(startTime: any): void;
    setBrushEndTime(endTime: any): void;
    setBrush(): void;
    private findClosestValidTime;
    private getMarkerMarginLeft;
    exportMarkers(): void;
    private createOnMarkerChange;
    private renderMarker;
    private sortMarkers;
    private getAllLinesTransitionsComplete;
    private importMarkers;
    private createSeriesLabelsMarker;
    private renderSeriesLabelsMarker;
    private renderAllMarkers;
    private focusOnEllipsis;
    private filteredValueExist;
    addMarker: () => void;
    private voronoiExists;
    private voronoiMousemove;
    private voronoiContextMenu;
    private voronoiClick;
    private getValueOfVisible;
    private brushBrush;
    private brushEnd;
    private focusMarkerLabel;
    labelMouseout: () => void;
    labelMouseover: (aggregateKey: string, splitBy?: string) => void;
    private drawBrushRange;
    private getSVGLeftOffset;
    updateBrushRange(): void;
    deleteBrushRange(): void;
    getYExtents(): any[];
    private nextStackedState;
    private clearBrush;
    private getVisibleNumerics;
    private getSwimlaneOffsets;
    private setSwimLaneYExtents;
    private getEventsCollapsedSwimlaneHeight;
    //returns an array of tuples of y offset and height for each visible aggregate group
    private createYOffsets;
    private heightNonNumeric;
    private getGroupYExtent;
    private getAggAxisType;
    private adjustSwimLanes;
    private overwriteSwimLanes;
    private createSwimlaneLabels;
    render(data: any, options: any, aggregateExpressionOptions: any): void;
    private createPlot;
}
export { LineChart as default };
